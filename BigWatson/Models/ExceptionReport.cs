using System;
using System.Text;
using JetBrains.Annotations;
using Realms;

namespace BigWatson.Models
{
    /// <summary>
    /// A class that represents a standalone crash report
    /// </summary>
    public sealed class ExceptionReport
    {
        #region Properties

        /// <summary>
        /// Gets the key of the current Exception
        /// </summary>
        [NotNull, PrimaryKey]
        public String Uid { get; }

        /// <summary>
        /// Gets the type of the exception for this crash report
        /// </summary>
        [NotNull]
        public String ExceptionType { get; }

        /// <summary>
        /// Gets the HResult associated to the exception
        /// </summary>
        public int HResult { get; }

        /// <summary>
        /// Gets the message that was generated when the Exception was thrown
        /// </summary>
        [NotNull]
        public String Message { get; }

        /// <summary>
        /// Gets the source of the Exception, if present
        /// </summary>
        [NotNull]
        public String Source { get; }

        /// <summary>
        /// Gets the StackTrace for the current Exception
        /// </summary>
        [NotNull]
        public String StackTrace { get; }

        /// <summary>
        /// Gets the version of the app when the exception was thrown
        /// </summary>
        [NotNull]
        public Version AppVersion { get; }

        /// <summary>
        /// Gets the time of the crash
        /// </summary>
        public DateTime CrashTime { get; }

        /// <summary>
        /// Gets the amount of memory that the app was using when the Exception was thrown
        /// </summary>
        public long UsedMemory { get; }

        #endregion

        internal ExceptionReport([NotNull] RealmExceptionReport report)
        {
            Uid = report.Uid;
            ExceptionType = report.ExceptionType;
            HResult = report.HResult;
            Message = report.Message ?? String.Empty;
            Source = report.Source ?? String.Empty;
            StackTrace = report.StackTrace ?? String.Empty;
            AppVersion = Version.Parse(report.AppVersion);
            CrashTime = DateTime.FromBinary(report.CrashTime);
            UsedMemory = report.UsedMemory;
        }

        #region Additional parameters

        /// <summary>
        /// Gets the minimum app version that generated this Exception type
        /// </summary>
        [Ignored]
        public Version MinExceptionVersion { get; internal set; }

        /// <summary>
        /// Gets the maximum app version that generated this Exception type
        /// </summary>
        [Ignored]
        public Version MaxExceptionVersion { get; internal set; }

        /// <summary>
        /// Gets the total number of times this Exception type was generated by the app
        /// </summary>
        [Ignored]
        public int ExceptionTypeOccurrencies { get; internal set; }

        /// <summary>
        /// Gets the extended info on the crash times for this instance
        /// </summary>
        [Ignored]
        public String CrashVersionsInfo
        {
            get
            {
                StringBuilder sb = new StringBuilder();
                sb.Append($"{ExceptionTypeOccurrencies} {(ExceptionTypeOccurrencies == 1 ? "time" : "times")}");
                sb.Append(", ");
                sb.Append(MaxExceptionVersion == null
                    ? $"in version {MinExceptionVersion}" 
                    : $"from {MinExceptionVersion} to {MaxExceptionVersion}");
                return sb.ToString();
            }
        }

        /// <summary>
        /// Gets the most recent crash time for this Exception type
        /// </summary>
        [Ignored]
        public DateTime RecentCrashTime { get; internal set; }

        /// <summary>
        /// Gets the first time this Exception type was generated
        /// </summary>
        [Ignored]
        public DateTime LessRecentCrashTime { get; internal set; }

        #endregion
    }
}